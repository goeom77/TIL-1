# Algorithm_06_0808

## ✨ 대표적인 정렬 방식의 종류

1. **버블 정렬**

    - 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
    - 시간 복잡도 : O(n^2)

    ```python
    # 슈도코드
    BubbleSort(a, N)                      # 정렬할 배열과 배열의 크기
      for i : N -> 1                      # 정렬될 구간의 끝
        for j : 0 -> i-1                  # 비교할 원소 중 왼쪽 원소의 인덱스
          if a[j] > a[j+1]                # 왼쪽 원소가 더 크면
            a[j] <-> a[j+1]               # 오른쪽 원소와 교환
    
    
    def BubbleSort(a, N):                 # 정렬할 List, N 원소수
      for i in range(N-1, 0, -1):         # 범위의 끝 위치
        for j in range(0, i):
          if arr[j] > arr[j+1]:
            arr[j], arr[j+1] = arr[j+1], arr[j]
    ```

2. **카운팅 정렬**

    - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
    - 제한사항
        - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
        - 집합 내의 가장 큰 정수를 알아야 함.
    - 시간 복잡도 : O(n+k)        *n은 리스트 길이, k는 정수의 최대값*

    ```python
    def CountingSort(A, B, k):
    # A [] -- 입력 배열 (1 to k)
    # B [] -- 정렬된 배열
    # C [] -- 카운트 배열
    
      C = [0] * (k+1)
      
      for i in range(0, len(A)):
        C[A[i]] += 1
      
      for i in range(1, len(C)):
        C[i] += C[i-1]
        
      for i in range(len(B)-1, -1, -1):
        C[A[i]] -= 1
        B[C[A[i]]] = A[i]
    ```

3. **선택 정렬**

4. 퀵 정렬

5. 삽입 정렬

6. 병합 정렬

<br/>

## ✨ 완전 검색

- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
- Brute-force 혹은 generate-and-test 기법이라고도 불림.
- 경우의 수가 상대적으로 작을 때 유용

<br/>

## ✨ 탐욕 (Greedy) 알고리즘

- 최적해를 구하는 데에 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 핳여 그것이 최적이라는 보장은 없음.
- 일반적으로 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 됨.
- **동작 과정**
    1. 해 선택 : 현재 상태에서 부분 문제의 최적해를 구한 뒤 이를 부분해 집합에 추가한다.
    2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지 검사한다.
    3. 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1부터 다시 시작한다.